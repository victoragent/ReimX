generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = "file:./sqlite.db"
}

model User {
  id              String          @id @default(cuid())
  username        String
  email           String          @unique
  password        String?
  tgAccount       String?
  whatsappAccount String?
  evmAddress      String?
  solanaAddress   String?
  chainAddresses  String?
  role            String          @default("user")
  status          String          @default("pending") // pending, active, suspended
  isApproved      Boolean         @default(false) // 管理员审核状态
  salaryUsdt      Float           @default(0)
  approvedBy      String?         // 审核管理员ID
  approvedAt      DateTime?       // 审核时间
  reimbursements          Reimbursement[] @relation("ReimbursementApplicant")
  reviewedReimbursements  Reimbursement[] @relation("ReimbursementReviewer")
  approvedReimbursements  Reimbursement[] @relation("ReimbursementApprover")
  salaryPayments          SalaryPayment[]
  passwordResetTokens   PasswordResetToken[]
  ledgerEntries   LedgerEntry[]     @relation("UserLedgerEntries")
  reviewedLedgers LedgerEntry[]     @relation("LedgerReviewer")
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
}

model Reimbursement {
  id                   String   @id @default(cuid())
  applicantId          String
  title                String
  description          String?
  expenseType          String   @default("other")
  amountOriginal       Float
  currency             String
  exchangeRateToUsd    Float
  amountUsdEquivalent  Float
  exchangeRateSource   String
  exchangeRateTime     DateTime
  isManualRate         Boolean  @default(false)
  convertedBy          String?
  chain                String   @default("evm")
  receiptUrl           String?
  reimbursementUrl     String?
  status               String   @default("submitted")
  reviewerId           String?
  approverId           String?
  txHash               String?
  reviewComment        String?
  reviewedAt           DateTime?
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  applicant            User     @relation("ReimbursementApplicant", fields: [applicantId], references: [id])
  reviewer             User?    @relation("ReimbursementReviewer", fields: [reviewerId], references: [id])
  approver             User?    @relation("ReimbursementApprover", fields: [approverId], references: [id])
}

model SalaryPayment {
  id             String   @id @default(cuid())
  userId         String
  month          String
  amountUsdt     Float
  paymentAmountUsdt Float?
  status         String   @default("pending")
  scheduledAt    DateTime?
  paidAt         DateTime?
  transactionHash String?
  notes          String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  user           User     @relation(fields: [userId], references: [id])

  @@unique([userId, month])
}

model PasswordResetToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  expiresAt DateTime
  createdAt DateTime @default(now())

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([expiresAt])
}

// Bookkeeping / Ledger System

// SQLite does not support Enum, using String with defaults

model LedgerEntry {
  id              String            @id @default(cuid())
  userId          String
  
  // type: SALARY_FIAT, FEE, DIGITAL_ASSET, REIMBURSEMENT_EXTRA, OTHER
  // type: Shared with Reimbursement: technology, marketing, administrative, hr, other
  type            String            @default("other")
  amountOriginal  Decimal
  currency        String
  amountUsdEquivalent Decimal       @default(0)
  
  title           String
  description     String?
  transactionDate DateTime          @default(now())
  
  attachmentUrl   String?
  txHash          String?
  
  // status: PENDING, APPROVED, REJECTED
  status          String            @default("PENDING")
  
  reviewedBy      String?
  reviewedAt      DateTime?
  reviewNote      String?
  
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  
  user            User              @relation("UserLedgerEntries", fields: [userId], references: [id])
  reviewer        User?             @relation("LedgerReviewer", fields: [reviewedBy], references: [id])
}
